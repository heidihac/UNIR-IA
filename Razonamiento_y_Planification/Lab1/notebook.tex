
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{lab1\_final}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \hypertarget{laboratorio-algoritmos-de-buxfasqueda}{%
\subsection{Laboratorio: Algoritmos de
búsqueda}\label{laboratorio-algoritmos-de-buxfasqueda}}

\hypertarget{miembros-del-grupo}{%
\paragraph{Miembros del grupo:}\label{miembros-del-grupo}}

\begin{itemize}
\tightlist
\item
  David Piñeiro López
\item
  Gonzalo Molina Márquez
\item
  Manuel Pasieka
\item
  Óscar Piqueras Segura
\item
  Samuel Eduardo Bermejo Bramley
\end{itemize}

El objetivo es realizar la implementación en Python de diferentes
algoritmos de búsqueda y comparar los resultados obtenidos.

El problema a resolver es el que se presenta en el enunciado del
laboratorio, con un mundo de bloques que parten de una configuración
inicial y queremos llegar a un estado final determinado.

    \hypertarget{pasos-previos}{%
\subsubsection{Pasos previos}\label{pasos-previos}}

Lo primero que vamos a hacer, es importar la función \texttt{time}, que
nos permitirá calcular el tiempo de ejecución de cada unos de los
algoritmos y poder comparar su eficiencia.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{c+c1}{\PYZsh{} Importamos la función \PYZsq{}time\PYZsq{}, para poder medir}
        \PY{c+c1}{\PYZsh{} el tiempo de ejecución de los diferentes algoritmos }
        \PY{k+kn}{from} \PY{n+nn}{time} \PY{k}{import} \PY{n}{time}
\end{Verbatim}


    También vamos a crear una clase utilitaria, llamada \texttt{Stats}, que
podrá utilizar cada un de los algoritmos de búsqueda implementados para
poder mostrar información estadística sobre su ejecución.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} Clase \PYZsq{}Stats\PYZsq{} para almacenar información estadística}
        \PY{c+c1}{\PYZsh{} sobre la ejecución de los algoritmos de búsqueda}
        \PY{k}{class} \PY{n+nc}{Stats}\PY{p}{:}
        
            
            
            \PY{c+c1}{\PYZsh{} Constructor}
            \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{algorithm}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm} \PY{o}{=} \PY{n}{algorithm}   \PY{c+c1}{\PYZsh{} Nombre del algoritmo}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{init\PYZus{}time} \PY{o}{=} \PY{l+m+mi}{0}           \PY{c+c1}{\PYZsh{} Momento en el que se inicia la ejecución}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{=} \PY{l+m+mi}{0}          \PY{c+c1}{\PYZsh{} Momento en el que finaliza la ejecución}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{0}       \PY{c+c1}{\PYZsh{} Número de nodos evaluados}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{open\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{0}          \PY{c+c1}{\PYZsh{} Número de nodos expandidos pero no evaluados}
        
                
                
            \PY{c+c1}{\PYZsh{} Muestra la información de un modo legible por pantalla}
            \PY{k}{def} \PY{n+nf}{describe}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{================================================================================}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ALGORITMO DE BÚSQUEDA: }\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm}\PY{p}{)}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Tiempo de ejecución: }\PY{l+s+si}{\PYZob{}0:.5f\PYZcb{}}\PY{l+s+s1}{ ms}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{\PYZhy{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{init\PYZus{}time}\PY{p}{)} \PY{o}{*} \PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Número de nodos evaluados: }\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{visited\PYZus{}nodes}\PY{p}{)}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Número de nodos expandidos pero no evaluados: }\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{open\PYZus{}nodes}\PY{p}{)}\PY{p}{)}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    Una implementación concreta de búsqueda puede usar esta clase
instanciándola con el nombre del algoritmo. A lo largo de su ejecución
para resolver un problema en particular, puede usar esta clase para
guardar información sobre el tiempo empleado, los nodos que se han
evaluado, y los nodos que se han expandido pero al final no han sido
evaluados.

La implementación de un algoritmo de búsqueda puede usar esta clase para
ir almacenando un conjunto de datos que permitan su evaluación y
comparación con otras implementaciones. La información que en princio
nos parece interesante es:

\begin{itemize}
\tightlist
\item
  Nombre del algoritmo.
\item
  Momento en el que se inicia la ejecución.
\item
  Momento en el que encuentra la solución (o ha expandido todos los
  nodos y no la ha encontrado).
\item
  Número de nodos evaluados.
\item
  Número de nodos expandidos pero que no ha sido necesario evaluar.
\end{itemize}

Además, la clase tiene su propio método para mostar por pantalla la
información de una manera legible.

    Un ejemplo de uso de la clase \texttt{Stats}, para que quede más claro,
podría ser:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{c+c1}{\PYZsh{} Creamos un objeto de tipo \PYZsq{}Stats\PYZsq{} con datos inventados}
        \PY{n}{st} \PY{o}{=} \PY{n}{Stats}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Súper algoritmo de búsqueda}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{st}\PY{o}{.}\PY{n}{init\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
        \PY{n}{st}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
        \PY{n}{st}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{647}
        \PY{n}{st}\PY{o}{.}\PY{n}{open\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{29}
        
        \PY{c+c1}{\PYZsh{} Mostramos la información estadística por pantalla}
        \PY{n}{st}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
================================================================================
ALGORITMO DE BÚSQUEDA: Súper algoritmo de búsqueda
--------------------------------------------------------------------------------
Tiempo de ejecución: 0.02694 ms
Número de nodos evaluados: 647
Número de nodos expandidos pero no evaluados: 29
--------------------------------------------------------------------------------

    \end{Verbatim}

    \hypertarget{definiciuxf3n-de-los-estados}{%
\subsubsection{Definición de los
estados}\label{definiciuxf3n-de-los-estados}}

Todas las implementaciones de algoritmos de búsqueda necesitan que se
represente de alguna forma el estado. Nosotros vamos a hacerlo creando
la clase \texttt{State}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} Clase `State`, que representa cada uno de los estados del problema a resolver}
        \PY{k}{class} \PY{n+nc}{State}\PY{p}{:}
        
            
            
            \PY{c+c1}{\PYZsh{} Constructor}
            \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{stack}\PY{p}{,} \PY{n}{table}\PY{p}{,} \PY{n}{description}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack} \PY{o}{=} \PY{n}{stack}               \PY{c+c1}{\PYZsh{} Lista de bloques apilados}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{table} \PY{o}{=} \PY{n}{table}               \PY{c+c1}{\PYZsh{} Conjunto de bloques sobre la mesa}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{description} \PY{o}{=} \PY{n}{description}   \PY{c+c1}{\PYZsh{} Descripción}
        
                
                
            \PY{c+c1}{\PYZsh{} Redefinición del operador de igualdad}
            \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}eq\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{other}\PY{p}{)}\PY{p}{:}
                \PY{k}{return} \PY{p}{(}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack} \PY{o}{==} \PY{n}{other}\PY{o}{.}\PY{n}{stack}\PY{p}{)} \PY{o+ow}{and} \PY{p}{(}\PY{n+nb}{set}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{table}\PY{p}{)} \PY{o}{==} \PY{n+nb}{set}\PY{p}{(}\PY{n}{other}\PY{o}{.}\PY{n}{table}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        
            
            
            \PY{c+c1}{\PYZsh{} Expansión del nodo}
            \PY{k}{def} \PY{n+nf}{expand}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
                
                \PY{n}{expand\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
                
                \PY{c+c1}{\PYZsh{} Generamos todos los posibles estados de colocar los bloques de la mesa en la pila}
                \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{table}\PY{p}{:}
                    \PY{n}{state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack} \PY{o}{+} \PY{p}{[}\PY{n}{item}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{table} \PY{o}{\PYZhy{}} \PY{p}{\PYZob{}}\PY{n}{item}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Ponemos }\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ en la pila}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{item}\PY{p}{)}\PY{p}{)}
                    \PY{n}{expand\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{state}\PY{p}{)}
                    
                \PY{c+c1}{\PYZsh{} Generamos el estado obtenido al quitar el bloque superior de la pila y dejarlo sobre la mesa}
                \PY{k}{if} \PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{:}
                    \PY{n}{new\PYZus{}stack} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}
                    \PY{n}{new\PYZus{}table} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{table}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}
                    \PY{n}{item} \PY{o}{=} \PY{n}{new\PYZus{}stack}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
                    \PY{n}{new\PYZus{}table}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{item}\PY{p}{)}
                    \PY{n}{state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{n}{new\PYZus{}stack}\PY{p}{,} \PY{n}{new\PYZus{}table}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Quitamos }\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ de la pila}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{item}\PY{p}{)}\PY{p}{)}
                    \PY{n}{expand\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{state}\PY{p}{)} 
                    
                \PY{c+c1}{\PYZsh{} Devolvemos el conjunto de estados generados}
                \PY{k}{return} \PY{n}{expand\PYZus{}list}
        
            
            
            \PY{c+c1}{\PYZsh{} Cálculo heurístico del coste para llegar al estado \PYZsq{}state\PYZsq{}}
            \PY{k}{def} \PY{n+nf}{calc\PYZus{}heuristic}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{)}\PY{p}{:}
                \PY{n}{state\PYZus{}len} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{state}\PY{o}{.}\PY{n}{stack}\PY{p}{)}
                \PY{n}{self\PYZus{}len}  \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack}\PY{p}{)}
                \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{self\PYZus{}len}\PY{p}{)}\PY{p}{:}
                    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{!=} \PY{n}{state}\PY{o}{.}\PY{n}{stack}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{:}
                        \PY{k}{return} \PY{p}{(}\PY{n}{state\PYZus{}len} \PY{o}{\PYZhy{}} \PY{n}{i}\PY{p}{)} \PY{o}{+} \PY{p}{(}\PY{n}{self\PYZus{}len} \PY{o}{\PYZhy{}} \PY{n}{i}\PY{p}{)}
                \PY{k}{return} \PY{n}{state\PYZus{}len} \PY{o}{\PYZhy{}} \PY{n}{self\PYZus{}len}
        
            
            
            \PY{c+c1}{\PYZsh{} Mostramos por pantalla el estado, de forma pseudo\PYZhy{}gráfica}
            \PY{k}{def} \PY{n+nf}{describe}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
                \PY{n}{state\PYZus{}diagram} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
                \PY{n}{first\PYZus{}item} \PY{o}{=} \PY{k+kc}{True}
                \PY{n}{state\PYZus{}1\PYZus{}diagram} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
                \PY{n}{state\PYZus{}2\PYZus{}diagram} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
                \PY{n}{state\PYZus{}3\PYZus{}diagram} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}
                \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stack}\PY{p}{:}
                    \PY{k}{if} \PY{p}{(}\PY{n}{first\PYZus{}item}\PY{p}{)}\PY{p}{:}
                        \PY{n}{state\PYZus{}1\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{    \PYZhy{}\PYZhy{}\PYZhy{} }\PY{l+s+s1}{\PYZsq{}}
                        \PY{n}{state\PYZus{}2\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{   | }\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{ |}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{item}\PY{p}{)}
                        \PY{n}{state\PYZus{}3\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{    \PYZhy{}\PYZhy{}\PYZhy{} }\PY{l+s+s1}{\PYZsq{}}
                        \PY{n}{first\PYZus{}item} \PY{o}{=} \PY{k+kc}{False}
                    \PY{k}{else}\PY{p}{:}
                        \PY{n}{item\PYZus{}diagram} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{    \PYZhy{}\PYZhy{}\PYZhy{} }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{\PYZsq{}}
                        \PY{n}{item\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{   | }\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{ |}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{item}\PY{p}{)}
                        \PY{n}{state\PYZus{}diagram} \PY{o}{=} \PY{n}{item\PYZus{}diagram} \PY{o}{+} \PY{n}{state\PYZus{}diagram}        
                \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{table}\PY{p}{:}
                    \PY{n}{state\PYZus{}1\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{    \PYZhy{}\PYZhy{}\PYZhy{} }\PY{l+s+s1}{\PYZsq{}}
                    \PY{n}{state\PYZus{}2\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{   | }\PY{l+s+si}{\PYZob{}0\PYZcb{}}\PY{l+s+s1}{ |}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{item}\PY{p}{)}
                    \PY{n}{state\PYZus{}3\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{    \PYZhy{}\PYZhy{}\PYZhy{} }\PY{l+s+s1}{\PYZsq{}}
                \PY{n}{state\PYZus{}diagram} \PY{o}{+}\PY{o}{=} \PY{n}{state\PYZus{}1\PYZus{}diagram} \PY{o}{+} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n}{state\PYZus{}2\PYZus{}diagram} \PY{o}{+} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n}{state\PYZus{}3\PYZus{}diagram}
                \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n}{state\PYZus{}diagram} \PY{o}{+} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    Para crear una instancia de la clase \texttt{State}, le proporcionamos
al constructor una lista (\texttt{list}), un conjunto (\texttt{set}) y
una cadena de caracteres:

\begin{itemize}
\tightlist
\item
  La propiedad \texttt{stack}, como lista ordenada es que es, la
  utilizamos para representar la pila de bloques ordenados.
\item
  La propiedad \texttt{table}, como conjunto, nos sirve para representar
  los bloques desordenados que están encima de la mesa.
\item
  Por último, la propiedad \texttt{description} nos ayuda a mantener una
  descripción asociada al estado.
\end{itemize}

Tras el constructor, vemos la \textbf{redefinición del operador de
igualdad}. Esto, como veremos más adelante, facilitará mucho la tarea de
comprobar si dos estados son equivalentes.

A continuación tenemos dos métodos muy importantes: \texttt{expand} y
\texttt{calc\_heuristic}.

\texttt{expand} realiza la expansión del nodo. Para ello, genera todos
los posibles estados a partir del actual: poner en la pila cualquiera de
los bloques de la mesa, o quitar de la pila el elemento superior y
dejarlo en la mesa.

\texttt{calc\_heuristic} es utilizado por los algoritmos de búsqueda
\textbf{A*} y \textbf{hill climbing}. Devuelve el cálculo heurístico del
coste de llegar a un estado concreto (el que se le especifica como
parámetro). Hemos optado por utilizar como heurística, el número de
bloques mal colocados en la pila más el número de bloques no colocados
todavía.

Y por último, el método \texttt{describe} muestra por pantalla de una
manera pseudo-gráfica la representación del estado.

    Veamos un ejemplo de cómo representar un estado gracias a esta clase.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{c+c1}{\PYZsh{} Creamos una representación del estado inicial del problema}
        \PY{n}{state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado inicial}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Lo mostramos por pantalla}
        \PY{n}{state}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

    --- 
   | A |
    --- 
   | D |
    ---     ---     --- 
   | E |   | C |   | B |
    ---     ---     --- 


    \end{Verbatim}

    \hypertarget{definiciuxf3n-de-los-nodos}{%
\subsubsection{Definición de los
nodos}\label{definiciuxf3n-de-los-nodos}}

Ahora que tenemos los estados, el siguiente paso es representar los
nodos que formarán los árboles de búsqueda de los algoritmos. Vamos a
implementar para ello la clase \texttt{Node}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{c+c1}{\PYZsh{} Clase `Node`, que representa cada uno de los nodos de los árboles de búsqueda}
        \PY{k}{class} \PY{n+nc}{Node}\PY{p}{:}
        
            
            
            \PY{c+c1}{\PYZsh{} Constructor}
            \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{father} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,} \PY{n}{g} \PY{o}{=} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{h} \PY{o}{=} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{state}     \PY{c+c1}{\PYZsh{} Estado}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{father} \PY{o}{=} \PY{n}{father}   \PY{c+c1}{\PYZsh{} Node padre}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{g} \PY{o}{=} \PY{n}{g}             \PY{c+c1}{\PYZsh{} Coste desde el estado inicial hasta el estado de este nodo}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{h} \PY{o}{=} \PY{n}{h}             \PY{c+c1}{\PYZsh{} Coste heurístico desde el estado de este nodo hasta el estado final}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{f} \PY{o}{=} \PY{n}{g} \PY{o}{+} \PY{n}{h}         \PY{c+c1}{\PYZsh{} Coste heurístico total}
        
                
            
            \PY{c+c1}{\PYZsh{} Detectamos ciclos, comprobando el estado del nodo con el estado de todos los antecesores}
            \PY{k}{def} \PY{n+nf}{is\PYZus{}bucle}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{)}\PY{p}{:}
                \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n+nb+bp}{self}
                \PY{k}{while} \PY{n}{current\PYZus{}node} \PY{o}{!=} \PY{k+kc}{None}\PY{p}{:}
                    \PY{k}{if} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state} \PY{o}{==} \PY{n}{state}\PY{p}{:} \PY{k}{return} \PY{k+kc}{True}
                    \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{father}
                \PY{k}{return} \PY{k+kc}{False}
        
            
            
            \PY{c+c1}{\PYZsh{} Mostramos por pantalla el nodo y sus antecesores, de forma pseudo\PYZhy{}gráfica}
            \PY{k}{def} \PY{n+nf}{describe\PYZus{}path}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
                \PY{n}{path} \PY{o}{=} \PY{p}{[}\PY{p}{]}
                \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n+nb+bp}{self}
                \PY{k}{while} \PY{n}{current\PYZus{}node} \PY{o}{!=} \PY{k+kc}{None}\PY{p}{:}
                    \PY{n}{path}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{current\PYZus{}node}\PY{p}{)}
                    \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{father}
                \PY{n}{path}\PY{o}{.}\PY{n}{reverse}\PY{p}{(}\PY{p}{)}
                \PY{n}{step} \PY{o}{=} \PY{l+m+mi}{0}
                \PY{k}{for} \PY{n}{node} \PY{o+ow}{in} \PY{n}{path}\PY{p}{:}
                    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{PASO }\PY{l+s+si}{\PYZob{}\PYZcb{}}\PY{l+s+s1}{: }\PY{l+s+si}{\PYZob{}\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{step}\PY{p}{,} \PY{n}{node}\PY{o}{.}\PY{n}{state}\PY{o}{.}\PY{n}{description}\PY{p}{)}\PY{p}{)}
                    \PY{n}{node}\PY{o}{.}\PY{n}{state}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
                    \PY{n}{step} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
\end{Verbatim}


    Para crear una instancia de la clase \texttt{Node} necesitamos

\begin{itemize}
\tightlist
\item
  Un estado, obligatoriamente.
\item
  Su nodo padre, si lo tiene. No es el primer nodo, su padre será
  \texttt{None}.
\item
  El coste (\textbf{g}) desde el estado inicial hasta el estado de este
  nodo.
\item
  El coste heurístico (\textbf{h}) desde el estado de este nodo hasta el
  estado final.
\end{itemize}

Estos dos últimos parámetros, sólo son necesarios para los algoritmos de
búsqueda \textbf{A*} y \textbf{hill climbing}. Además, también harán uso
de la propiedad \textbf{f}, que es el coste heurístico total.

El método más importante de la clase es \texttt{is\_bucle}. Se encarga
de detectar ciclos, tanto simples como generales. Para ello, compara el
estado del nodo con el estado de todos sus antecesores.

De nuevo en último lugar, el método \texttt{describe\_path} muestra por
pantalla de una manera pseudo-gráfica la representación del nodo y su
estado, así como la de todos sus antecesores.

\emph{\textbf{Nota:} Hemos utilizado la nomenclatura \textbf{{[}f{]}},
\textbf{{[}g{]}} y \textbf{{[}h{]}}, como se hace en el tema 6 de la
asignatura.}

    A continuación mostramos un ejemplo sencillo de cómo crear y mostrar un
nodo.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{\PYZsh{} Creamos una representación del estado inicial del problema}
        \PY{n}{state\PYZus{}1} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado inicial}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Creamos un nodo a partir del estado inicial}
        \PY{n}{node\PYZus{}1} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n}{state\PYZus{}1}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Creamos una representación de un posible siguiente estado}
        \PY{n}{state\PYZus{}2} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Se ha apilado B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Creamos un nodo a partir del segundo estado}
        \PY{n}{node\PYZus{}2} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n}{state\PYZus{}2}\PY{p}{,} \PY{n}{father} \PY{o}{=} \PY{n}{node\PYZus{}1}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Mostramos por pantalla el segundo nodo}
        \PY{c+c1}{\PYZsh{} (lo que visualizará también a sus antecesores)}
        \PY{n}{node\PYZus{}2}\PY{o}{.}\PY{n}{describe\PYZus{}path}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

PASO 0: Estado inicial

    --- 
   | A |
    --- 
   | D |
    ---     ---     --- 
   | E |   | C |   | B |
    ---     ---     --- 


PASO 1: Se ha apilado B

    --- 
   | B |
    --- 
   | A |
    --- 
   | D |
    ---     --- 
   | E |   | C |
    ---     --- 


    \end{Verbatim}

    \hypertarget{buxfasqueda-en-amplitud}{%
\subsubsection{Búsqueda en amplitud}\label{buxfasqueda-en-amplitud}}

Ya tenemos todo lo necesario para implementar el algoritmo de
\textbf{búsqueda en amplitud}.

Vamos a crear una clase, \texttt{search\_breadth\_first}, con un único
método: \texttt{search}. Este método se encargará de buscar la solución
para ir del estado inicial al estado objetivo indicados en el
constructor de la clase.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} Implementación de la búsqueda en amplitud}
        \PY{k}{class} \PY{n+nc}{search\PYZus{}breadth\PYZus{}first}\PY{p}{:}
        
            
            
            \PY{c+c1}{\PYZsh{} Constructor }
            \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{state}                                       \PY{c+c1}{\PYZsh{} Estado inicial}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{goal\PYZus{}state}                             \PY{c+c1}{\PYZsh{} Estado objetivo}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats} \PY{o}{=} \PY{n}{Stats}\PY{p}{(}\PY{n}{algorithm} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Búsqueda en amplitud}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}   \PY{c+c1}{\PYZsh{} Inicializamos un objeto de tipo \PYZsq{}Stats\PYZsq{}}
        
                
                
            \PY{c+c1}{\PYZsh{} Método de búsqueda    }
            \PY{k}{def} \PY{n+nf}{search}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
                
                \PY{c+c1}{\PYZsh{} Empezamos a medir el tiempo}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{init\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
                
                \PY{c+c1}{\PYZsh{} No hemos procesado ningún nodo}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{0}
                
                \PY{c+c1}{\PYZsh{} Obtenemos el nodo inicial...}
                \PY{n}{initial\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
                \PY{c+c1}{\PYZsh{} ... y lo añadimos a la lista de nodos a procesar}
                \PY{n}{open\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{n}{initial\PYZus{}node}\PY{p}{]}
                
                \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
                    
                    \PY{c+c1}{\PYZsh{} Si hemos procesado todos los nodos, generamos un error}
                    \PY{k}{assert} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Se han explorado todos los nodos sin éxito.}\PY{l+s+s1}{\PYZsq{}}
                    
                    \PY{c+c1}{\PYZsh{} Sacamos el primer nodo de la lista}
                    \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
                    
                    \PY{c+c1}{\PYZsh{} Lo consideramos procesado}
                    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
                    
                    \PY{c+c1}{\PYZsh{} Hemos llegado al objetivo, salimos del bucle}
                    \PY{k}{if} \PY{p}{(}\PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state} \PY{o}{==} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                        \PY{k}{break}
                        
                    \PY{c+c1}{\PYZsh{} No hemos llegado al objetivo}
                    \PY{k}{else}\PY{p}{:}
                        
                        \PY{c+c1}{\PYZsh{} Expandimos los estados}
                        \PY{n}{succesors} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state}\PY{o}{.}\PY{n}{expand}\PY{p}{(}\PY{p}{)}
                        \PY{k}{for} \PY{n}{succesor} \PY{o+ow}{in} \PY{n}{succesors}\PY{p}{:}
                            \PY{c+c1}{\PYZsh{} Si no se trata de un ciclo...}
                            \PY{k}{if} \PY{o+ow}{not} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{is\PYZus{}bucle}\PY{p}{(}\PY{n}{succesor}\PY{p}{)}\PY{p}{:}
                                \PY{c+c1}{\PYZsh{} ... creamos un nuevo estado}
                                \PY{n}{succesor\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n}{succesor}\PY{p}{,} \PY{n}{father} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{p}{)}
                                \PY{c+c1}{\PYZsh{} ... y lo insertamos al final}
                                \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{succesor\PYZus{}node}\PY{p}{)}
                
                \PY{c+c1}{\PYZsh{} Dejamos de medir el tiempo de ejecución}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
                
                \PY{c+c1}{\PYZsh{} Indicamos el número de nodos que no hemos procesado}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{open\PYZus{}nodes} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)}
                
                \PY{c+c1}{\PYZsh{} Devolvemos el nodo con la solución}
                \PY{k}{return} \PY{n}{current\PYZus{}node}
\end{Verbatim}


    A continuación evaluamos su funcionamiento, teniendo en cuenta el estado
inicial y el estado objetivo del enunciado del laboratorio.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} Estado inicial}
        \PY{n}{initial\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado inicial}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} Estado objetivo}
        \PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado objetivo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Instanciamos el algoritmo}
        \PY{n}{search\PYZus{}algorithm} \PY{o}{=} \PY{n}{search\PYZus{}breadth\PYZus{}first}\PY{p}{(}\PY{n}{initial\PYZus{}state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} Realizamos la búsqueda}
        \PY{n}{result} \PY{o}{=} \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{search}\PY{p}{(}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Mostramos los datos estadísticos...}
        \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} ... y la solución encontrada}
        \PY{n}{result}\PY{o}{.}\PY{n}{describe\PYZus{}path}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
================================================================================
ALGORITMO DE BÚSQUEDA: Búsqueda en amplitud
--------------------------------------------------------------------------------
Tiempo de ejecución: 0.40603 ms
Número de nodos evaluados: 18
Número de nodos expandidos pero no evaluados: 16
--------------------------------------------------------------------------------

PASO 0: Estado inicial

    --- 
   | A |
    --- 
   | D |
    ---     ---     --- 
   | E |   | C |   | B |
    ---     ---     --- 


PASO 1: Quitamos A de la pila

    --- 
   | D |
    ---     ---     ---     --- 
   | E |   | C |   | B |   | A |
    ---     ---     ---     --- 


PASO 2: Ponemos C en la pila

    --- 
   | C |
    --- 
   | D |
    ---     ---     --- 
   | E |   | B |   | A |
    ---     ---     --- 


PASO 3: Ponemos B en la pila

    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    ---     --- 
   | E |   | A |
    ---     --- 


PASO 4: Ponemos A en la pila

    --- 
   | A |
    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    --- 
   | E |
    --- 


    \end{Verbatim}

    \hypertarget{buxfasqueda-en-profundidad}{%
\subsubsection{Búsqueda en
profundidad}\label{buxfasqueda-en-profundidad}}

Ya tenemos todo lo necesario para implementar el algoritmo de
\textbf{búsqueda en profundidad}.

Vamos a crear una clase, \texttt{search\_depth\_first}, con un único
método: \texttt{search}. Este método se encargará de buscar la solución
para ir del estado inicial al estado objetivo indicados en el
constructor de la clase.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{} Implementación de la búsqueda en profundidad}
         \PY{k}{class} \PY{n+nc}{search\PYZus{}depth\PYZus{}first}\PY{p}{:}
         
             
             
             \PY{c+c1}{\PYZsh{} Constructor}
             \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{state}                                          \PY{c+c1}{\PYZsh{} Estado inicial}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{goal\PYZus{}state}                                \PY{c+c1}{\PYZsh{} Estado objetivo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats} \PY{o}{=} \PY{n}{Stats}\PY{p}{(}\PY{n}{algorithm} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Búsqueda en profundidad}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}   \PY{c+c1}{\PYZsh{} Inicializamos un objeto de tipo \PYZsq{}Stats\PYZsq{}}
         
                 
                 
             \PY{c+c1}{\PYZsh{} Método de búsqueda    }
             \PY{k}{def} \PY{n+nf}{search}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
         
                 \PY{c+c1}{\PYZsh{} Empezamos a medir el tiempo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{init\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} No hemos procesado ningún nodo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{0}
                 
                 \PY{c+c1}{\PYZsh{} Obtenemos el nodo inicial...}
                 \PY{n}{initial\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
                 \PY{c+c1}{\PYZsh{} ... y lo añadimos a la lista de nodos a procesar        }
                 \PY{n}{open\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{n}{initial\PYZus{}node}\PY{p}{]}        
                 
                 \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
                 
                     \PY{c+c1}{\PYZsh{} Si hemos procesado todos los nodos, generamos un error}
                     \PY{k}{assert} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Se han explorado todos los nodos sin éxito.}\PY{l+s+s1}{\PYZsq{}}
         
                     \PY{c+c1}{\PYZsh{} Sacamos el último nodo de la lista}
                     \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
         
                     \PY{c+c1}{\PYZsh{} Lo consideramos procesado}
                     \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
         
                     \PY{c+c1}{\PYZsh{} Hemos llegado al objetivo, salimos del bucle}
                     \PY{k}{if} \PY{p}{(}\PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state} \PY{o}{==} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                         \PY{k}{break}
         
                     \PY{c+c1}{\PYZsh{} No hemos llegado al objetivo}
                     \PY{k}{else}\PY{p}{:}
                         
                         \PY{c+c1}{\PYZsh{} Expandimos los estados}
                         \PY{n}{succesors} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state}\PY{o}{.}\PY{n}{expand}\PY{p}{(}\PY{p}{)}
                         \PY{k}{for} \PY{n}{succesor} \PY{o+ow}{in} \PY{n}{succesors}\PY{p}{:}
                             \PY{c+c1}{\PYZsh{} Si no se trata de un ciclo...}
                             \PY{k}{if} \PY{o+ow}{not} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{is\PYZus{}bucle}\PY{p}{(}\PY{n}{succesor}\PY{p}{)}\PY{p}{:}
                                 \PY{c+c1}{\PYZsh{} ... creamos un nuevo estado}
                                 \PY{n}{succesor\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n}{succesor}\PY{p}{,} \PY{n}{father} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{p}{)}
                                 \PY{c+c1}{\PYZsh{} ... y lo ponemos insertamos al final}
                                 \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{succesor\PYZus{}node}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Dejamos de medir el tiempo de ejecución}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Indicamos el número de nodos que no hemos procesado}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{open\PYZus{}nodes} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Devolvemos el nodo con la solución}
                 \PY{k}{return} \PY{n}{current\PYZus{}node}
\end{Verbatim}


    A continuación evaluamos su funcionamiento, teniendo en cuenta el estado
inicial y el estado objetivo del enunciado del laboratorio.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{c+c1}{\PYZsh{} Estado inicial}
         \PY{n}{initial\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado inicial}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} Estado objetivo}
         \PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado objetivo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Instanciamos el algoritmo}
         \PY{n}{search\PYZus{}algorithm} \PY{o}{=} \PY{n}{search\PYZus{}depth\PYZus{}first}\PY{p}{(}\PY{n}{initial\PYZus{}state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} Realizamos la búsqueda}
         \PY{n}{result} \PY{o}{=} \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{search}\PY{p}{(}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Mostramos los datos estadísticos...}
         \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} ... y la solución encontrada}
         \PY{n}{result}\PY{o}{.}\PY{n}{describe\PYZus{}path}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
================================================================================
ALGORITMO DE BÚSQUEDA: Búsqueda en profundidad
--------------------------------------------------------------------------------
Tiempo de ejecución: 2.61283 ms
Número de nodos evaluados: 322
Número de nodos expandidos pero no evaluados: 2
--------------------------------------------------------------------------------

PASO 0: Estado inicial

    --- 
   | A |
    --- 
   | D |
    ---     ---     --- 
   | E |   | C |   | B |
    ---     ---     --- 


PASO 1: Quitamos A de la pila

    --- 
   | D |
    ---     ---     ---     --- 
   | E |   | C |   | B |   | A |
    ---     ---     ---     --- 


PASO 2: Ponemos C en la pila

    --- 
   | C |
    --- 
   | D |
    ---     ---     --- 
   | E |   | B |   | A |
    ---     ---     --- 


PASO 3: Ponemos B en la pila

    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    ---     --- 
   | E |   | A |
    ---     --- 


PASO 4: Ponemos A en la pila

    --- 
   | A |
    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    --- 
   | E |
    --- 


    \end{Verbatim}

    \hypertarget{buxfasqueda-a}{%
\subsubsection{Búsqueda A*}\label{buxfasqueda-a}}

Ya tenemos todo lo necesario para implementar el algoritmo de
\textbf{búsqueda A*}.

Vamos a crear una clase, \texttt{search\_A\_star}, con un único método:
\texttt{search}. Este método se encargará de buscar la solución para ir
del estado inicial al estado objetivo indicados en el constructor de la
clase.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{c+c1}{\PYZsh{} Implementación de la búsqueda A*}
         \PY{k}{class} \PY{n+nc}{search\PYZus{}A\PYZus{}star}\PY{p}{:}
         
             
             
             \PY{c+c1}{\PYZsh{} Constructor}
             \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{state}                              \PY{c+c1}{\PYZsh{} Estado inicial}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{goal\PYZus{}state}                    \PY{c+c1}{\PYZsh{} Estado objetivo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats} \PY{o}{=} \PY{n}{Stats}\PY{p}{(}\PY{n}{algorithm} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Búsqueda A*}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}   \PY{c+c1}{\PYZsh{} Inicializamos un objeto de tipo \PYZsq{}Stats\PYZsq{}}
         
                 
                 
             \PY{c+c1}{\PYZsh{} Método de búsqueda    }
             \PY{k}{def} \PY{n+nf}{search}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
         
                 \PY{c+c1}{\PYZsh{} Empezamos a medir el tiempo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{init\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} No hemos procesado ningún nodo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{0}
         
                 \PY{c+c1}{\PYZsh{} Obtenemos el nodo inicial...}
                 \PY{n}{initial\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
                 \PY{c+c1}{\PYZsh{} ... y lo añadimos a la lista de nodos a procesar        }
                 \PY{n}{open\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{n}{initial\PYZus{}node}\PY{p}{]}
         
                 \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
                     
                     \PY{c+c1}{\PYZsh{} Si hemos procesado todos los nodos, generamos un error}
                     \PY{k}{assert} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Se han explorado todos los nodos sin éxito.}\PY{l+s+s1}{\PYZsq{}}
         
                     \PY{c+c1}{\PYZsh{} Sacamos el primer nodo de la lista}
                     \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
                     \PY{c+c1}{\PYZsh{} Lo consideramos procesado}
                     \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
         
                     \PY{c+c1}{\PYZsh{} Hemos llegado al objetivo, salimos del bucle}
                     \PY{k}{if} \PY{p}{(}\PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state} \PY{o}{==} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                         \PY{k}{break}
                         
                     \PY{c+c1}{\PYZsh{} No hemos llegado al objetivo}
                     \PY{k}{else}\PY{p}{:}
                         
                         \PY{c+c1}{\PYZsh{} Expandimos los estados}
                         \PY{n}{succesors} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state}\PY{o}{.}\PY{n}{expand}\PY{p}{(}\PY{p}{)}
                         \PY{k}{for} \PY{n}{succesor} \PY{o+ow}{in} \PY{n}{succesors}\PY{p}{:}
                             \PY{c+c1}{\PYZsh{} Si no se trata de un ciclo...}
                             \PY{k}{if} \PY{o+ow}{not} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{is\PYZus{}bucle}\PY{p}{(}\PY{n}{succesor}\PY{p}{)}\PY{p}{:}
                                 \PY{c+c1}{\PYZsh{} ... creamos un nuevo estado}
                                 \PY{n}{succesor\PYZus{}g} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{g} \PY{o}{+} \PY{l+m+mi}{1}
                                 \PY{n}{succesor\PYZus{}h} \PY{o}{=} \PY{n}{succesor}\PY{o}{.}\PY{n}{calc\PYZus{}heuristic}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state}\PY{p}{)}
                                 \PY{n}{succesor\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n}{succesor}\PY{p}{,} \PY{n}{father} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{p}{,} \PY{n}{g} \PY{o}{=} \PY{n}{succesor\PYZus{}g}\PY{p}{,} \PY{n}{h} \PY{o}{=} \PY{n}{succesor\PYZus{}h}\PY{p}{)}
                                 \PY{c+c1}{\PYZsh{} ... y lo ponemos insertamos}
                                 \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{succesor\PYZus{}node}\PY{p}{)}
                         \PY{c+c1}{\PYZsh{} Ordenamos la lista de abiertos según su heurística}
                         \PY{n}{open\PYZus{}list} \PY{o}{=} \PY{n+nb}{sorted}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{,} \PY{n}{key} \PY{o}{=} \PY{k}{lambda} \PY{n}{node}\PY{p}{:} \PY{n}{node}\PY{o}{.}\PY{n}{f}\PY{p}{)}
                         
                 \PY{c+c1}{\PYZsh{} Dejamos de medir el tiempo de ejecución}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Indicamos el número de nodos que no hemos procesado}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{open\PYZus{}nodes} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Devolvemos el nodo con la solución}
                 \PY{k}{return} \PY{n}{current\PYZus{}node}
\end{Verbatim}


    A continuación evaluamos su funcionamiento, teniendo en cuenta el estado
inicial y el estado objetivo del enunciado del laboratorio.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} Estado inicial}
         \PY{n}{initial\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado inicial}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} Estado objetivo}
         \PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado objetivo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Instanciamos el algoritmo}
         \PY{n}{search\PYZus{}algorithm} \PY{o}{=} \PY{n}{search\PYZus{}A\PYZus{}star}\PY{p}{(}\PY{n}{initial\PYZus{}state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} Realizamos la búsqueda}
         \PY{n}{result} \PY{o}{=} \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{search}\PY{p}{(}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Mostramos los datos estadísticos...}
         \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} ... y la solución encontrada}
         \PY{n}{result}\PY{o}{.}\PY{n}{describe\PYZus{}path}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
================================================================================
ALGORITMO DE BÚSQUEDA: Búsqueda A*
--------------------------------------------------------------------------------
Tiempo de ejecución: 0.17881 ms
Número de nodos evaluados: 5
Número de nodos expandidos pero no evaluados: 5
--------------------------------------------------------------------------------

PASO 0: Estado inicial

    --- 
   | A |
    --- 
   | D |
    ---     ---     --- 
   | E |   | C |   | B |
    ---     ---     --- 


PASO 1: Quitamos A de la pila

    --- 
   | D |
    ---     ---     ---     --- 
   | E |   | C |   | B |   | A |
    ---     ---     ---     --- 


PASO 2: Ponemos C en la pila

    --- 
   | C |
    --- 
   | D |
    ---     ---     --- 
   | E |   | B |   | A |
    ---     ---     --- 


PASO 3: Ponemos B en la pila

    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    ---     --- 
   | E |   | A |
    ---     --- 


PASO 4: Ponemos A en la pila

    --- 
   | A |
    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    --- 
   | E |
    --- 


    \end{Verbatim}

    \hypertarget{buxfasqueda-por-ascenso-de-colinas}{%
\subsubsection{Búsqueda por ascenso de
colinas}\label{buxfasqueda-por-ascenso-de-colinas}}

Ya tenemos todo lo necesario para implementar el algoritmo de
\textbf{búsqueda por ascenso de colinas}.

Vamos a crear una clase, \texttt{search\_hill\_climbing}, con un único
método: \texttt{search}. Este método se encargará de buscar la solución
para ir del estado inicial al estado objetivo indicados en el
constructor de la clase.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{c+c1}{\PYZsh{} Implementación de la búsqueda por ascenso de colinas}
         \PY{k}{class} \PY{n+nc}{search\PYZus{}hill\PYZus{}climbing}\PY{p}{:}
         
             
             
             \PY{c+c1}{\PYZsh{} Constructor}
             \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{state}                                                  \PY{c+c1}{\PYZsh{} Estado inicial}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{goal\PYZus{}state}                                        \PY{c+c1}{\PYZsh{} Estado objetivo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats} \PY{o}{=} \PY{n}{Stats}\PY{p}{(}\PY{n}{algorithm} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Búsqueda por ascenso de colinas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}   \PY{c+c1}{\PYZsh{} Inicializamos un objeto de tipo \PYZsq{}Stats\PYZsq{}}
         
                 
                 
             \PY{c+c1}{\PYZsh{} Método de búsqueda    }
             \PY{k}{def} \PY{n+nf}{search}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
         
                 \PY{c+c1}{\PYZsh{} Empezamos a medir el tiempo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{init\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} No hemos procesado ningún nodo}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{=} \PY{l+m+mi}{0}
         
                 \PY{c+c1}{\PYZsh{} Obtenemos el nodo inicial...}
                 \PY{n}{initial\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
                 \PY{c+c1}{\PYZsh{} ... y lo añadimos a la lista de nodos a procesar        }
                 \PY{n}{open\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{n}{initial\PYZus{}node}\PY{p}{]}
         
                 \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
                     
                     \PY{c+c1}{\PYZsh{} Si hemos procesado todos los nodos, generamos un error}
                     \PY{k}{assert} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Se han explorado todos los nodos sin éxito.}\PY{l+s+s1}{\PYZsq{}}
         
                     \PY{c+c1}{\PYZsh{} Sacamos el primer nodo de la lista}
                     \PY{n}{current\PYZus{}node} \PY{o}{=} \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
                     \PY{c+c1}{\PYZsh{} Lo consideramos procesado}
                     \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{visited\PYZus{}nodes} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
         
                     \PY{c+c1}{\PYZsh{} Hemos llegado al objetivo, salimos del bucle}
                     \PY{k}{if} \PY{p}{(}\PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state} \PY{o}{==} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state}\PY{p}{)}\PY{p}{:}
                         \PY{k}{break}
                         
                     \PY{c+c1}{\PYZsh{} No hemos llegado al objetivo}
                     \PY{k}{else}\PY{p}{:}
         
                         \PY{c+c1}{\PYZsh{} Expandimos los estados}
                         \PY{n}{succesors} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{state}\PY{o}{.}\PY{n}{expand}\PY{p}{(}\PY{p}{)}
                         \PY{n}{succesors\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{p}{]}
                         \PY{k}{for} \PY{n}{succesor} \PY{o+ow}{in} \PY{n}{succesors}\PY{p}{:}
                             \PY{c+c1}{\PYZsh{} Si no se trata de un ciclo...}
                             \PY{k}{if} \PY{o+ow}{not} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{is\PYZus{}bucle}\PY{p}{(}\PY{n}{succesor}\PY{p}{)}\PY{p}{:}
                                 \PY{c+c1}{\PYZsh{} ... creamos un nuevo estado}
                                 \PY{n}{succesor\PYZus{}g} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{o}{.}\PY{n}{g} \PY{o}{+} \PY{l+m+mi}{1}
                                 \PY{n}{succesor\PYZus{}h} \PY{o}{=} \PY{n}{succesor}\PY{o}{.}\PY{n}{calc\PYZus{}heuristic}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{goal\PYZus{}state}\PY{p}{)}
                                 \PY{n}{succesor\PYZus{}node} \PY{o}{=} \PY{n}{Node}\PY{p}{(}\PY{n}{state} \PY{o}{=} \PY{n}{succesor}\PY{p}{,} \PY{n}{father} \PY{o}{=} \PY{n}{current\PYZus{}node}\PY{p}{,} \PY{n}{g} \PY{o}{=} \PY{n}{succesor\PYZus{}g}\PY{p}{,} \PY{n}{h} \PY{o}{=} \PY{n}{succesor\PYZus{}h}\PY{p}{)}
                                 \PY{c+c1}{\PYZsh{} ... y lo insertamos}
                                 \PY{n}{succesors\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{succesor\PYZus{}node}\PY{p}{)}
                         \PY{c+c1}{\PYZsh{} Ordenamos la lista de abiertos según la heurística...}
                         \PY{n}{succesors\PYZus{}list} \PY{o}{=} \PY{n+nb}{sorted}\PY{p}{(}\PY{n}{succesors\PYZus{}list}\PY{p}{,} \PY{n}{key} \PY{o}{=} \PY{k}{lambda} \PY{n}{node}\PY{p}{:} \PY{n}{node}\PY{o}{.}\PY{n}{f}\PY{p}{)}
                         \PY{c+c1}{\PYZsh{} ... y nos quedamos con el mejor}
                         \PY{n}{open\PYZus{}list}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{succesors\PYZus{}list}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}
                         
                 \PY{c+c1}{\PYZsh{} Dejamos de medir el tiempo de ejecución}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{final\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{p}{(}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Indicamos el número de nodos que no hemos procesado}
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{open\PYZus{}nodes} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{open\PYZus{}list}\PY{p}{)}
         
                 \PY{c+c1}{\PYZsh{} Devolvemos el nodo con la solución}
                 \PY{k}{return} \PY{n}{current\PYZus{}node}
\end{Verbatim}


    A continuación evaluamos su funcionamiento, teniendo en cuenta el estado
inicial y el estado objetivo del enunciado del laboratorio.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{c+c1}{\PYZsh{} Estado inicial}
         \PY{n}{initial\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado inicial}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} Estado objetivo}
         \PY{n}{goal\PYZus{}state} \PY{o}{=} \PY{n}{State}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{E}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{D}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{B}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Estado objetivo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Instanciamos el algoritmo}
         \PY{n}{search\PYZus{}algorithm} \PY{o}{=} \PY{n}{search\PYZus{}hill\PYZus{}climbing}\PY{p}{(}\PY{n}{initial\PYZus{}state}\PY{p}{,} \PY{n}{goal\PYZus{}state}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} Realizamos la búsqueda}
         \PY{n}{result} \PY{o}{=} \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{search}\PY{p}{(}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Mostramos los datos estadísticos...}
         \PY{n}{search\PYZus{}algorithm}\PY{o}{.}\PY{n}{stats}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} ... y la solución encontrada}
         \PY{n}{result}\PY{o}{.}\PY{n}{describe\PYZus{}path}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
================================================================================
ALGORITMO DE BÚSQUEDA: Búsqueda por ascenso de colinas
--------------------------------------------------------------------------------
Tiempo de ejecución: 0.07987 ms
Número de nodos evaluados: 5
Número de nodos expandidos pero no evaluados: 0
--------------------------------------------------------------------------------

PASO 0: Estado inicial

    --- 
   | A |
    --- 
   | D |
    ---     ---     --- 
   | E |   | C |   | B |
    ---     ---     --- 


PASO 1: Quitamos A de la pila

    --- 
   | D |
    ---     ---     ---     --- 
   | E |   | C |   | B |   | A |
    ---     ---     ---     --- 


PASO 2: Ponemos C en la pila

    --- 
   | C |
    --- 
   | D |
    ---     ---     --- 
   | E |   | B |   | A |
    ---     ---     --- 


PASO 3: Ponemos B en la pila

    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    ---     --- 
   | E |   | A |
    ---     --- 


PASO 4: Ponemos A en la pila

    --- 
   | A |
    --- 
   | B |
    --- 
   | C |
    --- 
   | D |
    --- 
   | E |
    --- 


    \end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
